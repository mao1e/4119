#!/usr/bin/env python3

from socket import *
import time
import sys
import re
import threading

def thread_func(connectionSocket, addr, file, alpha):
  print("accepted from ", addr)
  #THIS IS WHERE YOU CONNECT TO THE SERVER
  clientSocket = socket(AF_INET, SOCK_STREAM)

  #bind to fake-ip, port 0 (any available)
  clientSocket.bind((sys.argv[5], 0))

  #server address is server-ip and port is fixed 80
  serverName = '127.0.0.1' #this will be changed later
  serverPort = 80
  # Connect to the server's listening socket
  clientSocket.connect((serverName, serverPort))
  tput_curr = 0
  def receive_client_msg(socket_to_use):
      encodedClientMessage = socket_to_use.recv(2048)
      if not encodedClientMessage:
          return encodedClientMessage

      # Decode the recieved binary message into a string
      decodedClientMessage = encodedClientMessage.decode('iso-8859-1')

      #keep recv if not reached EOM \n
      while(len(decodedClientMessage) > 0 and
              decodedClientMessage[-4:] != '\r\n\r\n'):
          print("loop")
          encodednextmsg = socket_to_use.recv(2048)
          if not encodednextmsg:
              break
          decodednextmsg = encodednextmsg.decode()
          decodedClientMessage += decodednextmsg
      return decodedClientMessage
  bitrates = []
  #keep allowing client and server to send messages to each other
  while 1==1:
      tput_new = 0
      writestr = str(time.time())
      curr_bitrate = 0

      decodedClientMessage = receive_client_msg(connectionSocket)
      if not decodedClientMessage:
          break
      if (len(bitrates) == 0 and re.search(r'BigBuckBunny_6s_nolist\.mpd', decodedClientMessage)):
          print('replaced no list')
          decodedClientMessage = re.sub(r'BigBuckBunny_6s_nolist\.mpd', 'BigBuckBunny_6s.mpd', decodedClientMessage)
      elif (re.search(r'bunny_(\d+)bps', decodedClientMessage)):
          print('no list done, fetch bitrate')
          print(bitrates)
          curr_bitrate = bitrates[0]
          for bitrate, index in enumerate(bitrates):
              if bitrate * 1.5 > tput_curr:
                  curr_bitrate = bitrates[index - 1]
                  break
              if index == len(bitrates) - 1:
                  curr_bitrate = bitrate
          print('replacing bitrate')
          bitrate_pattern = r'bunny_(\d+)bps'
          decodedClientMessage = re.sub(
            bitrate_pattern,
            f'bunny_{curr_bitrate}bps',
            decodedClientMessage
          )
      headers = decodedClientMessage.split("\n")
      filename = ""
      for header in headers:
          if "GET" in header:
              firstline = header.split(" ")
              filename = firstline[1]
      print("Received Message from Client: ", len(decodedClientMessage))

      message = decodedClientMessage
      print("Sending Message to Server: ", len(message))

      # Encode the message into binary
      encodedMessage = message.encode()

      # Send the encoded message to the server
      clientSocket.send(encodedMessage)
      firsttime = time.time()

      if ((len(bitrates) == 0 and re.search(r'BigBuckBunny_6s', decodedClientMessage))):
          decodedServerMessage = receive_client_msg(clientSocket)
          if not decodedServerMessage:
              break
          bitrate_pattern = r'bandwidth="(\d+)"'
          found_bitrates = [int(match.group(1)) for match in re.finditer(bitrate_pattern, decodedServerMessage)]
          bitrates = found_bitrates
          tput_curr = min(bitrates)
          bitrates.sort()
          print('getting bitrates from xml below this line')
          print(bitrates)
          connectionSocket.send(decodedServerMessage.encode())
          continue
      # Receive the modified message back from the server
      encodedServerMessage = clientSocket.recv(1)

      #stop the conversation if server disconnects
      if not encodedServerMessage:
          break

      # Decode the modified message back into a string
      decodedServerMessage = encodedServerMessage.decode('iso-8859-1')
      #keep recv if not EOM is not \n
      while(len(decodedServerMessage) > 0 and 
               "\r\n\r\n" not in decodedServerMessage):
          encodednextmsg = clientSocket.recv(1)
          encodedServerMessage += encodednextmsg
          if not encodednextmsg:
              break
          decodednextmsg = encodednextmsg.decode()
          decodedServerMessage += decodednextmsg
      print("Received Message from Server: ", len(decodedServerMessage))
      index = decodedServerMessage.find("\r\n\r\n")
      responseheaders = decodedServerMessage
      headers = responseheaders.split("\n")
      clength = 0
      for header in headers:
           if "Content-Length: " in header:
              clength = int(header[16:])
      
      connectionSocket.send(encodedServerMessage)

      print("Sending Message to Client: ", len(encodedServerMessage))
      # Sending the encoded modified message back to the client
      totalsent = 0
      all_chunks = []
      while(totalsent < clength):
          recieved_chunk = clientSocket.recv(2048)
          if not recieved_chunk:
              print('i broke')
              break
          all_chunks.append(recieved_chunk)
          totalsent += 2048
      secondtime = time.time() 
      for chunk in all_chunks:
          connectionSocket.send(chunk)
      writestr += " " + str(secondtime - firsttime) + " " + str(sys.argv[4])
      tput_new = clength / (secondtime - firsttime)
      tput_curr = alpha * tput_new + (1 - alpha) * tput_curr

      writestr += " " + filename + " " + str(clength) + "\n"
      file.write(writestr)
      file.flush()
 
  clientSocket.close()
  connectionSocket.close()






serverSocket = socket(AF_INET, SOCK_STREAM)

#accept from any address but only listen-port
serverSocket.bind(('' , int(sys.argv[4])))

serverSocket.listen(1)

#open file
file = open(sys.argv[2], "w")
threads = []

#keep connecting to new client and server when they are disconnected
while 1==1:
  connectionSocket, addr = serverSocket.accept()
  alpha = float(sys.argv[3])
  t = threading.Thread(target = thread_func, args = (connectionSocket, addr, file, alpha))
  t.start()
  threads.append(t)

for t in threads:
    t.join()
serverSocket.close()
file.close()
